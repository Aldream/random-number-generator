
# coding: utf-8

# # Pseudo-Random Number Generators
# 
# ## Project for *The Art of Mathematical Computing* Seminar

# The code below is part of my study on **Random Number Generators** for the *The Art of Mathematical Computing* Seminar.
# 
# It demonstrates how to implement some **Pseudo-Random Number Generators** in Python, but also how to *crack* some of them. This code thus contains:
# 
# 1. Implementation of the LFSR Generators
# 2. Implementation of the Berlekamp-Massey algorithm to predict the structure of the forementioned generators
# 3. Implementation of the harder-to-crack NLFRS Generators

# ### 1. LFSR Generators

# In[1]:

import math # Only used for math.pow

def createLFSRgenerator(taps, seed):
    """
        Returns a LFSR generator, defined by the given sequence of taps and initial value.
        @param taps (Tuple[int]): Sequence of taps defining the register.
            The length of the tuple defines the size of the register (number of bits)
            The 1st (resp. last) element corresponds to the most-significant (resp. less-) bit of the register (1 = XOR tap)
            ex: (1, 0, 0, 1) represents the register of feedback polynomial x^4 + x^3 + 1
        @param seed (int):        Initial value given to the register
        @return                   LFSR Generator
    """
    def lfsrGen():
        """
            Yields values generated by a pre-defined LFSR (defined by the feedback polynomial represented by `taps` and the initial value `seed`)
            @yield Pseudo-Random value
        """
        deg = len(taps)              # Degree of the feedback polynomial
        period = math.pow(2,deg) - 1 # Period of the LFSR
        value = seed                 # Initial value
        it = 0
        while (it < period):
            # Computing first the new value of the most-significant bit:
            bit = 0
            for j in range(deg): # AND-operation between the current value and the taps-tuple
                if taps[j]:
                    bit ^= value >> j
            bit &= 1 # XOR-operation to get the new value of the bit
            
            # Getting the final value in the register by popping the less-significant bit and appending the new most-significant one:
            value = (value >> 1) | (bit << (deg-1))
            it += 1
            yield value
    return lfsrGen


# In[2]:

# Util:
def getBitFromInt(val, pos):
    """
        Return the binary value of the chosen bit in the given value.
        @param val (int): Value
        @param pos (int): Position of the bit
        @return           Bit value (int)
    """
    return val & (1 << pos)


# ##### Tests:

# In[3]:

print("# Test 1.1 - LFSR with x^4 + x + 1 as feedback polynomial and 13 as initial value")
lfsr4 = createLFSRgenerator((1,0,0,1), 13)()
# Getting its sequence of 2^4 - 1 = 15 pseudo-random values:
valuesLFSR4 = [i for i in lfsr4]
print("Values:")
print(valuesLFSR4)

print()
print('---------------')
print()

print("# Test 1.2 - LFSR with x^16 + x^14 + x^13 + x^11 + 1 as feedback polynomial and 0xACE1 = 44257 as initial value")
lfsr16 = createLFSRgenerator((1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0), 0xACE1)()
print("Next Value (expected: 0xE270 = 22128):")
print(next(lfsr16))


# ### 2. Berlekamp-Massey Algorithm

# In[4]:

def BerlekampMasseyAlgorithm(sequence):
    """
        Applies the Berlekamp-Massey Algorithm to the given sequence of bits;
        Returns the smallest annihilating polynomial F, ie. the smallest inverse
        feedback polynomial corresponding to the generating LFSR.( F(sequence) = 0 )
        @param sequence (Array[int] or Tuple[int]): Sequence of bits to analyze
        @returns Array defining the computed inverse feedback polynomial
            ex: [1, 0, 0, 1, 1] represents the inverse polynomial x^4 + x^3 + 1,
                and thus the feedback polynomial x^4 + x + 1 (taps = (1, 0, 0, 1))
    """
    
    def discrepancy(sequence, poly, i, L):
        """
            Returns the discrepancy.
            @param sequence (Array[int] or Tuple[int]): Sequence of bits to analyze
            @param poly (Array[int]):                   Current version of the inverse polynomial
            @param i (int):                             Current position in the sequence
            @param L (int):                             Current number of assumed errors
            @return                                     Binary value of the discrepancy
        """
        return sum([sequence[i-j]&poly[j] for j in range(0,L+1)])%2 # = s[i]*p[i] + s[i-1]*p[1] + ... + s[i-L]*p[L]
    
    def addPoly(poly1, poly2, length):
        """
            Computes the addition of two F2 polynomials.
            @param poly1 (Array[int]): Array representing the 1st polynomial
            @param poly2 (Array[int]): Array representing the 2nd polynomial
            @param length (int):       Length to be covered by the addition (trusting user to avoid testing)
            @returns                   Resulting Binary Array 
        """
        return [poly1[j]^poly2[j] for j in range(0, length)]

    # Notes: the variables names are based on those in the pseudo-code found in
    #        JOUX, Antoine. Algorithmic cryptanalysis. CRC Press, 2009.,
    #        Algorithm 2.14, page 56
    
    # Initializing: 
    N = len(sequence)

    F, f = [0]*N, [0]*N # Polynomials, with F being the one returned at the end (inverse feedback polynomial)
    F[0] = f[0] = 1
    L = 0               # Current number of assumed errors
    delta = 1           # Number of iterations since last update of L

    # Computing F and L:
    for l in range(N):
        beta = discrepancy(sequence, F, l, L)
        # If the discrepancy is null, we can assume that F and L are currently correct and can continue with the next term.
        # Else, we must adjust F:
        if beta != 0:
            # Adjusting F for this term:
            g = F.copy()
            F = addPoly(F, [0]*delta + f, N)
            
            # L represents the number of error, so the discrepancies will reach 0 before l grows bigger than 2*L
            # If it is not the case, we must update L (and thus re-initalize delta), and also f:
            if 2 * L <= l:
                L = l + 1 - L # number of available syndromes used to calculate discrepancies
                delta = 1
                f = g # f get the previous value of F
            else:
                delta += 1
        else:
            delta += 1

    # output the polynomial
    return F[:L+1]


# In[5]:

# Util:
def polyToString(polynomial):
    """
        Returns a string representation of the F2 polynomial defined by the given array.
        ex: [1, 0, 0, 1] -> "x^3 + 1"
        @param polynomial (Array[int]): Polynomial to stringify
        @return                         Stringified polynomial
    """
    L = len(polynomial) - 1
    result = ''
    for i in range(L-1):
        if polynomial[i]:
            result += 'x^%s + ' % str(L-i)
    if polynomial[L]:
         result += '1'
    else:
         result = result[:-2]
    return result

def getTapsSequenceFromAnnihilatingPoly(poly):
    """
        Returns the taps sequence corresponding to the given annihilating polynomial.
        ex: [1, 1, 0, 0, 1] -> (1, 0, 0, 1)
            cf reverse(x^4 + x^3 + 1, deg=4) = x^4 + x + 1 which is thus the feedback polynomial, represented by the taps (1, 0, 0, 1).
        @param poly (Array[int]): Annihilating polynomial
        @return                   Taps sequence
    """
    polyInv = poly.copy()
    polyInv.reverse()
    return tuple(polyInv[:-1])


# #### Test:

# In[6]:

# Let's check if our algorithm can crack the LFSR from our previous test:
print('# Test 2.1 - using the LFSR with x^4 + x + 1 (1, 0, 0, 1) as feedback polynomial and 13 as initial value')

# Getting the bit sequence from the values generated by lfsr4:
sequenceLFSR4 = [getBitFromInt(i,0) for i in valuesLFSR4]
print('Pseudo-Random Sequence: ' + str(sequenceLFSR4))

# Testing:
annihPolyLFSR4 = BerlekampMasseyAlgorithm(sequenceLFSR4)
print ('Obtained Annihilating Polynomial: ' + polyToString(annihPolyLFSR4))
print ('Corresponding Taps Sequence: ' + str(getTapsSequenceFromAnnihilatingPoly(annihPolyLFSR4)))

print()
print('---------------')
print()

print('# Test 2.2 - using the LFSR with x^16 + x^14 + x^13 + x^11 + 1 as feedback polynomial and 0xACE1 = 44257 as initial value')
print('## Test 2.2.1 - Trying with a too short sequence (31 elements):')
sequenceLFSR16 = [getBitFromInt(next(lfsr16),0) for i in range(31)]
annihPolyLFSR16 = BerlekampMasseyAlgorithm(sequenceLFSR16)
print ('Obtained Annihilating Polynomial: ' + polyToString(annihPolyLFSR16))
print ('Corresponding Taps Sequence: ' + str(getTapsSequenceFromAnnihilatingPoly(annihPolyLFSR16)))

print()

print('## Test 2.2.2 - Trying with a long enough sequence (32 elements):')
sequenceLFSR16 = [getBitFromInt(next(lfsr16),0) for i in range(32)]
annihPolyLFSR16 = BerlekampMasseyAlgorithm(sequenceLFSR16)
print ('Obtained Annihilating Polynomial: ' + polyToString(annihPolyLFSR16))
print ('Corresponding Taps Sequence: ' + str(getTapsSequenceFromAnnihilatingPoly(annihPolyLFSR16)))


# ### 3. NFLSR

# In[23]:

def createNLFSRgenerator(taps, deg, seed):
    """
        Returns a NLFSR generator, defined by the given combination of taps and initial value.
        Warning: A given unproper feedback function will lead to a poor generator, with a small period.
                 For more information, check:
                      DUBROVA, Elena. A List of Maximum Period NLFSRs. IACR Cryptology ePrint Archive, 2012, vol. 2012, p. 166.
        @param taps (Tuple[Array[int]]): Sequence of combination of taps defining the non-linear register.
            The length of the tuple defines the size of the register (number of bits).
            The arrays defines each combination of elements.
            ex: ([0],[1],[2],[3,2]) represents the register of feedback polynomial x^4 + x^3 + x^2  + x^1*x^2 + 1 (good function)
            ex: ([0,0],[],[2],[3,2]) represents the register of feedback polynomial x^4*x^4 + x^2  + x^1*x^2 + 1 (poor function)
        @param seed (int):              Initial value given to the register
        @param deg (int):               Size of the register
        @return                         NLFSR Generator
    """
    def nlfsrGen():
        """
            Yields values generated by a pre-defined NLFSR (defined by the feedback polynomial represented by `taps` and the initial value `seed`)
            @yield Pseudo-Random value
        """
        period = math.pow(2,deg) - 1 # Max Period of the NLFSR (read Warning above)
        value = seed                 # Initial value
        it = 0
        while (it < period):
            # Computing the new value of the most-significant bit:
            bit = 0
            for tap in taps:
                # Computing the binary multiplication x^K_0 * x^K_1 * ... * x^K_n with [K_0, K_1, ..., K_n] the j-th taps array
                if len(tap):
                    element = 1
                    for k in tap:
                        if not (value >> k & 1):
                            # Binary multiplication of terms returns 1 iif none of the terms is null.
                            # So if we encounter a null bit, we simply return 0, else 1.
                            element = 0
                            break
                else:
                    element = 0
                # Binary addition of the multiplication results:
                bit ^= element
            bit &= 1
            
            # Getting the final value in the register by popping the less-significant bit and appending the new most-significant one:
            value = (value >> 1) | (bit << (deg-1))
            it += 1
            yield value
    return nlfsrGen


# #### Test:

# In[27]:

print("# Test 3.1 - LFSR with x^4 + x + 1 as feedback polynomial and 13 as initial value, using our NLFSR function")
lfsr4FromNlfsrMethod = createNLFSRgenerator(([0],[3]), 4, 13)()
print("Values:")
print([i for i in lfsr4FromNlfsrMethod])
print("Comparing with the values obtained with the LFSR generator initialized with the same feedback function:")
print(valuesLFSR4)

print()
print('---------------')
print()

print("# Test 3.2 - Poor NLFSR with x^4*x^4*x^3 + x^1*x^2 + x^1*x^3 + 1 as feedback polynomial and 13 as initial value")
poorNlfsr = createNLFSRgenerator(([0,0,1],[3,2],[3,1]), 4, 13)()
print("Values:")
print([i for i in poorNlfsr])

print()
print('---------------')
print()

print("# Test 3.3 - Better NLFSR with x^4 + x^3 + x^2  + x^1*x^2 + 1 as feedback polynomial and 13 as initial value")
nlfsr4 = createNLFSRgenerator(([0],[1],[2],[3,2]), 4, 13)()
print("Values:")
valuesNLFSR4 = [i for i in nlfsr4]
print(valuesNLFSR4)


print()
print('---------------')
print()

print("# Test 3.4 - Applying Berlekamp-Massey algorithm to the previous sequence generated by the NLFSR")

sequenceNLFSR4 = [getBitFromInt(i,0) for i in valuesNLFSR4]
wrongAnnihPolyNLFSR4 = BerlekampMasseyAlgorithm(sequenceNLFSR4)
print ('Obtained Annihilating Polynomial: ' + polyToString(wrongAnnihPolyNLFSR4))
print ('Corresponding Taps Sequence: ' + str(getTapsSequenceFromAnnihilatingPoly(wrongAnnihPolyNLFSR4)))


# In[ ]:



