function createLFSRGenerator(taps, seed) {
	/*
	Returns a LFSR generator, defined by the given sequence of taps and initial value.
	@param taps (Tuple[int]): Sequence of taps defining the register.
		The length of the tuple defines the size of the register (number of bits)
		The 1st (resp. last) element corresponds to the most-significant (resp. less-) bit of the register (1 = XOR tap)
		ex: (1, 0, 0, 1) represents the register of feedback polynomial x^4 + x^3 + 1
	@param seed (int):        Initial value given to the register
	@return                   LFSR Generator
	*/
		
	return function *lfsrGen() {
        /*
            Yields values generated by a pre-defined LFSR (defined by the feedback polynomial represented by `taps` and the initial value `seed`)
            @yield Pseudo-Random value
        */
		var deg = taps.length,              // Degree of the feedback polynomial
            period = Math.pow(2, deg) - 1,   // Max period of the LFSR
            value = seed;                     // Initial value
        // for (var it = 0; it < period; it++) { // Computing new value of most-significant bit:
        for (;;) {
			var bit = 0;
            for (var j = 0; j < deg; j++) {   // AND-operation between the current value and the taps-tuple
                if (taps[j])
                    bit ^= value >> j;
            }
            bit &= 1; // XOR-operation to get the new value of the bit
            // Final value in register by popping less-sign bit and appending the new most-sign one:
            yield (value = (value >> 1) | (bit << (deg - 1)));
        }
    }
}

function getBitFromInt(val, pos) {
    /*
        Return the binary value of the chosen bit in the given value.
        @param val (int): Value
        @param pos (int): Position of the bit
        @return           Bit value (int)
    */
    return val & (1 << pos);
}

function BerlekampMasseyAlgorithm(sequence) {
    /*
        Applies the Berlekamp-Massey Algorithm to the given sequence of bits;
        Returns the smallest annihilating polynomial F, ie. the smallest inverse
        feedback polynomial corresponding to the generating LFSR.( F(sequence) = 0 )
        @param sequence (Array[int] or Tuple[int]): Sequence of bits to analyze
        @returns Array defining the computed inverse feedback polynomial
            ex: [1, 0, 0, 1, 1] represents the inverse polynomial x^4 + x^3 + 1,
                and thus the feedback polynomial x^4 + x + 1 (taps = (1, 0, 0, 1))
    */
    
    function discrepancy(sequence, poly, i, L) {
        /*
            Returns the discrepancy.
            @param sequence (Array[int] or Tuple[int]): Sequence of bits to analyze
            @param poly (Array[int]):                   Current version of the inverse polynomial
            @param i (int):                             Current position in the sequence
            @param L (int):                             Current number of assumed errors
            @return                                     Binary value of the discrepancy
        */
		var disc = 0;
		for (var j = 0; j < L+1; j++) {
			disc += (sequence[i-j] & poly[j]) // disc = s[i]*p[i] + s[i-1]*p[1] + ... + s[i-L]*p[L]
		}
		return disc%2;
	}
    
	function addPoly(poly1, poly2, length) {
        /*
            Computes the addition of two F2 polynomials.
            @param poly1 (Array[int]): Array representing the 1st polynomial
            @param poly2 (Array[int]): Array representing the 2nd polynomial
            @param length (int):       Length to be covered by the addition (trusting user to avoid testing)
            @returns                   Resulting Binary Array 
        */
		var poly = [];
		for (var j = 0; j < length; j++) {
			poly.push(poly1[j] ^ poly2[j]);
		}
		return poly;
	}

    // Notes: the variables names are based on those in the pseudo-code found in
    //        JOUX, Antoine. Algorithmic cryptanalysis. CRC Press, 2009.,
    //        Algorithm 2.14, page 56
    
    // Initializing: 
    var N = sequence.length;

    var F = [], f = [] // Polynomials, with F being the one returned at the end (inverse feedback polynomial)
	for (var i = 0; i < N; i++) { F.push(0); f.push(0); }
    F[0] = f[0] = 1
    var L = 0               // Current number of assumed errors
    var delta = 1           // Number of iterations since last update of L

    // Computing F and L:
    for (var l = 0; l < N; l++) {
        var beta = discrepancy(sequence, F, l, L);
        // If the discrepancy is null, we can assume that F and L are currently correct and can continue with the next term.
        // Else, we must adjust F:
        if (beta != 0) {
            // Adjusting F for this term:
            var g = F.slice(0);
			var fShifted = f.slice(0);
			for (var k = 0; k < delta; k++) { fShifted.unshift(0); }
            F = addPoly(F, fShifted, N);
            
            // L represents the number of error, so the discrepancies will reach 0 before l grows bigger than 2*L
            // If it is not the case, we must update L (and thus re-initalize delta), and also f:
            if (2 * L <= l) {
                L = l + 1 - L; // number of available syndromes used to calculate discrepancies
                delta = 1;
                f = g; // f get the previous value of F
            } else {
                delta += 1;
			}
		} else {
            delta += 1;
		}
	}

	for (var k = L+1; k < N; k++) { F.pop(); }
    // output the polynomial
    return F;
}

function polyToString(polynomial) {
    /*
        Returns a string representation of the F2 polynomial defined by the given array.
        ex: [1, 0, 0, 1] -> "x^3 + 1"
        @param polynomial (Array[int]): Polynomial to stringify
        @return                         Stringified polynomial
    */
    var L = polynomial.length - 1;
    var result = '';
    for (var i = 0; i < L-1; i++) {
        if (polynomial[i])
            result += 'x^'+(L-i)+' + ';
	}
    if (polynomial[L])
         result += '1';
    else
         result = result.slice(0, -2);
    return result;
}

function getTapsSequenceFromAnnihilatingPoly(poly) {
    /*
        Returns the taps sequence corresponding to the given annihilating polynomial.
        ex: [1, 1, 0, 0, 1] -> (1, 0, 0, 1)
            cf reverse(x^4 + x^3 + 1, deg=4) = x^4 + x + 1 which is thus the feedback polynomial, represented by the taps (1, 0, 0, 1).
        @param poly (Array[int]): Annihilating polynomial
        @return                   Taps sequence
    */
    var polyInv = poly.slice(0);
    polyInv.reverse();
	polyInv.pop();
    return polyInv;
}

function createNLFSRgenerator(taps, deg, seed) {
    /*
        Returns a NLFSR generator, defined by the given combination of taps and initial value.
        Warning: A given unproper feedback function will lead to a poor generator, with a small period.
                 For more information, check:
                      DUBROVA, Elena. A List of Maximum Period NLFSRs. IACR Cryptology ePrint Archive, 2012, vol. 2012, p. 166.
        @param taps (Tuple[Array[int]]): Sequence of combination of taps defining the non-linear register.
            The length of the tuple defines the size of the register (number of bits).
            The arrays defines each combination of elements.
            ex: ([0],[1],[2],[1,2]) represents the register of feedback polynomial x^4 + x^3 + x^2  + x^1*x^2 + 1 (good function)
            ex: ([0,0],[],[2],[1,2]) represents the register of feedback polynomial x^4*x^4 + x^2  + x^1*x^2 + 1 (poor function)
        @param deg (int):              	Size of the register
        @param seed (int):              Initial value given to the register
        @return                         NLFSR Generator
    */
    return function *nlfsrGen() {
        /*
            Yields values generated by a pre-defined NLFSR (defined by the feedback polynomial represented by `taps` and the initial value `seed`)
            @yield Pseudo-Random value
        */
        var	period = Math.pow(2,deg) - 1, // Max Period of the NLFSR (read Warning above)
			value = seed;                 // Initial value
		// var it = 0
			
        // while (it < period) {
		for (;;) {
            // Computing the new value of the most-significant bit:
            var	bit = 0;
            for (var j = 0; j < taps.length; j++) {
				var	element = 1;
                if (taps[j].length) {
                    // Computing the binary multiplication x^K_0 * x^K_1 * ... * x^K_n with [K_0, K_1, ..., K_n] the j-th taps array
                    for (var k = 0; k < taps[j].length; k++) {
                        if (!(value >> taps[j][k] & 1)) {
                            // Binary multiplication of terms returns 1 iif none of the terms is null.
                            // So if we encounter a null bit, we simply return 0, else 1.
                            element = 0;
                            break;
						 }
					}
				} else {
                    element = 0;
				}
                // Binary addition of the multiplication results:
                bit ^= element;
			}
            bit &= 1;
            
            // Getting the final value in the register by popping the less-significant bit and appending the new most-significant one:
            // it += 1;
			
			yield (value = (value >> 1) | (bit << (deg-1)));
		}
	}
}

// Function for UI:

function binPolyStringToArray(string, deg) {
    /*
        Converts a string expressing a binary polynomial to an array of the given size.
		ex: if string = "x^9 +x^3 + 1" and deg = 10, it returns [0,1,0,0,0,0,0,1,0,0,1]
        @param string (String): String containing the expression of the polynomial
        @param deg (int): Size of the array to return
        @return Binary Array
    */
	
	var syndromes = string.replace(/\s/g,'').split('+');
	console.log(syndromes);
	var taps = [];
	for (var i = 0; i < syndromes.length; i++) {
		var x = syndromes[i].split('^');
		if (x.length == 2) {
			taps.push(parseInt(x[1]));
		}
		else if (x[0] == 'x') {
			taps.push(1);
		}
		else if (x[0] == '1') {
			taps.push(0);
		}
		
	}
	var poly = [];
	
	for (var i = deg; i > 0; i--) {
		poly.push(0);
	}
	for (var i = 0; i < taps.length; i++) {
		poly[poly.length - taps[i]] = 1;
	}
	return poly;
}
function nlBinPolyStringToArray(string, deg) {
    /*
        Converts a string expressing a non-linear binary polynomial to an array of the given size.
		ex: if string = "x^9 * x^3 +x^3 + 1" and deg = 9, it returns [[0,6], [6], [9]]
        @param string (String): String containing the expression of the polynomial
        @param deg (int): Size of the array to return
        @return Taps Array
    */
	
	var syndromes = string.replace(/\s/g,'').split('+');
	var taps = [];
	for (var i = 0; i < syndromes.length; i++) {
		var product = syndromes[i].split('*');
		var t = [];
		for (var j = 0; j < product.length; j++) {
			var x = product[j].split('^');
			if (x.length == 2) {
				t.push(deg-parseInt(x[1]));
			}
			else if (x[0] == 'x') {
				t.push(deg-1);
			}
			else if (x[0] == '1') {
				t.push(deg);
			}
		}
		taps.push(t);
	}
	return taps;
}